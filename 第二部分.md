#### 第二部分 语言基础
##### 第五章 消息
OC方法与C函数区别: 实际上,编译器最终将方法转变为C函数

- 方法定义在它们的类的一个特定实例上执行.方法接受指向对象实例的一个指针,其形式是隐藏了self
- 方法可以直接访问对象的实例变量,而不需要声明它们
- 命名方法及其参数的语法,与命名函数的语法不同
多参方法:

```
- (void)methodWithVariableNumberOfArguments:(id)arg1, ...;
```
**方法名都以一个小写字母开头,并且,名称部分中任何后续的单词都是首字母大写的**

*严格来说,在冒号之前并不一定要有任何的名称字符*

*setColors:(UIColor \*)outlineColor :(UIColor \*)fillColor* 对应的方法 -> setColors::

函数调用:通常是静态绑定的,即在运行时执行的代码,在编译时就已经确定了.

发送消息:OC运行时检查接收者并确定其类,并获取方法名,然后在接受者的类表中找到该方法对应的指针,然后使用该指针执行方法的代码.

**包含了消息表达式的函数或者代码块就是发送者**

发送消息解释:

```
1.所有的OC对象知道它们的类. -> 编译器给每个对象实例添加一个实例变量,名为isa;isa说明一个实例是什么类型的对象.在运行时,isa指向类的类结构,其中包含了有关类的信息,包括该类所定义的实例变量和方法;并且还有一个指针,指向有关其超类的类信息.当启动时,这些信息在运行时填充.
2.编译器将方法转换成实际编译的C函数.在这一过程中,它在参数列表的开始处添加两个额外的参数,self,_cmd.self是一个指针,指向发送消息时充当接收者的对象,_cmd是与消息的方法名对应的选择器
3.每个OC类都有一个表,这个表将一个方法的选择器与指向实现该方法的函数的一个指针链接起来.给定了选择器,运行时可以使用这个表来匹配的函数的指针.每个类也有一个缓存机制,以加速对一个给定方法的后续搜索.

```

```
Shape *aShape = ...;
UIColor *newFillColor = ...;
[aShape setFillColor:newFillColor];

-> objc_msgSend(aShape, @selector(setFillColor:), newFillColor);
```
极少情况下,发送消息的负载可能会是一个问题,可使用如下方法解决:

```
IMP *anIMP = [aShape methodForSelector:@selector(setFillColor:)];
(* anIMP)(aShape, @selector(setFillColor:), newFillColor);
```

**OC消息系统的灵活性带来一些性能上的代价.对于时间性重要的代码来说,也可能绕过消息系统而直接调用方法,尽管在实际情况中,很少这么做.消息发送所发的时间,通常比执行方法体所花费的时间要少很多**

##### 第六章 类和对象
@class 指令:

- 通过减少依赖性而缩短编译时间
- 解决相互引用的问题

导入:

接口部分和实现部分放入不同的文件中

-> 如果结接口部分和实现部分在同一个文件中,则导入接口部分也会导入实现了该类的代码,这会导致实现代码的多个副本.这么做会导致编译器错误,编译器会给出一条关于重复符号的提示. 

-> 在一种情况下,将类定义的两个部分都放入到同一个文件中是没有问题的.如果你有一个辅助类,它只在另一个类中使用,则可以将辅助类的两个部分都放入到主类的实现文件中.辅助类的接口部分应该放在辅助类和主类的实现部分之前.

内省:在运行时确定一个对象的类的能力

抽象类:OC中没有语法用来声明一个方法是抽象的或者虚拟的.如果创建了一个抽象类,那么对于要求抽象类的子类实现的方法,应该提供一个空的实现.

创建对象:

```
alloc的作用:
1.为新对象分配内存,并返回指向该内存的指针
2.填充对象的isa实例变量
3.清空其他的对象的内存.除isa以外的所有实例都以0值开始
4.将新创建的对象的引用计数设置为1
```
```
init的返回值:
1.init方法可能会释放其接收者,并且替代了属于最初的接收者的超类的对象.对于那些实现为类簇的类来说,经常发生这种事情.
类簇:一个公共装饰类,它负责管理一组私有子类.当分配并初始化这个公共类的一个实例时,我们实际接受的是一个私有子类的实例. 它是一种设计模式,它将多个私有子类隐藏到一个公有的可见的抽象类的背后,当请求公有类的一个实例时,接受到的是一个私有子类的实例.
2.相同的init方法可以用于不同的类的接收者.将一个init方法的返回值的类型确定为id(instancetype),这允许继承了声明该方法的初始类的哪些类,可以继承并使用该方法.
```
为一个类设计初始化程序:

```
1.所有其他的类初始化程序,最终必须调用该类的(而不是超类的)指定初始化程序.
2.类的指定初始化程序必须调用其超类的指定初始化程序.指定初始化程序,时调用超类的指定初始化程序的唯一初始化程序.
3.自定义初始化类,必须考虑覆盖init
```
**应该在类的文档中注明哪一个初始化程序是指定初始化程序.**

复制:对于copyWithZone:通常的建议是,调用copyWithZone:的超类实现以创建新的副本,并且填充超类中定义的任何实例变量.copyWithZone:的子类实现的其余部分填充子类中定义的实例变量,并且返回该副本.

```
- (id)copyWithZone:(NSZone *)zone {
	id copiedTeeShirt = [[[self class] allocWithZone:zone] initWithShirtSize:[self shirtSize] color:[self shirtColor]];
	return copiedTeeShirt;
}
```






