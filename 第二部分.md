#### 第二部分 语言基础
##### 第五章 消息
OC方法与C函数区别: 实际上,编译器最终将方法转变为C函数

- 方法定义在它们的类的一个特定实例上执行.方法接受指向对象实例的一个指针,其形式是隐藏了self
- 方法可以直接访问对象的实例变量,而不需要声明它们
- 命名方法及其参数的语法,与命名函数的语法不同
多参方法:

```
- (void)methodWithVariableNumberOfArguments:(id)arg1, ...;
```
**方法名都以一个小写字母开头,并且,名称部分中任何后续的单词都是首字母大写的**

*严格来说,在冒号之前并不一定要有任何的名称字符*

*setColors:(UIColor \*)outlineColor :(UIColor \*)fillColor* 对应的方法 -> setColors::

函数调用:通常是静态绑定的,即在运行时执行的代码,在编译时就已经确定了.

发送消息:OC运行时检查接收者并确定其类,并获取方法名,然后在接受者的类表中找到该方法对应的指针,然后使用该指针执行方法的代码.

**包含了消息表达式的函数或者代码块就是发送者**

发送消息解释:

```
1.所有的OC对象知道它们的类. -> 编译器给每个对象实例添加一个实例变量,名为isa;isa说明一个实例是什么类型的对象.在运行时,isa指向类的类结构,其中包含了有关类的信息,包括该类所定义的实例变量和方法;并且还有一个指针,指向有关其超类的类信息.当启动时,这些信息在运行时填充.
2.编译器将方法转换成实际编译的C函数.在这一过程中,它在参数列表的开始处添加两个额外的参数,self,_cmd.self是一个指针,指向发送消息时充当接收者的对象,_cmd是与消息的方法名对应的选择器
3.每个OC类都有一个表,这个表将一个方法的选择器与指向实现该方法的函数的一个指针链接起来.给定了选择器,运行时可以使用这个表来匹配的函数的指针.每个类也有一个缓存机制,以加速对一个给定方法的后续搜索.

```

```
Shape *aShape = ...;
UIColor *newFillColor = ...;
[aShape setFillColor:newFillColor];

-> objc_msgSend(aShape, @selector(setFillColor:), newFillColor);
```
极少情况下,发送消息的负载可能会是一个问题,可使用如下方法解决:

```
IMP *anIMP = [aShape methodForSelector:@selector(setFillColor:)];
(* anIMP)(aShape, @selector(setFillColor:), newFillColor);
```

**OC消息系统的灵活性带来一些性能上的代价.对于时间性重要的代码来说,也可能绕过消息系统而直接调用方法,尽管在实际情况中,很少这么做.消息发送所发的时间,通常比执行方法体所花费的时间要少很多**



